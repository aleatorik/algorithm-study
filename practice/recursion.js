//반복문을 사용하여 1부터 100까지의 '합' 구하기
/* let s = 0;
      for (var i = 1; i < 101; i++) {
        s += i;
      }
      console.log(s);
     */
//반복문을 사용하여 1부터 5까지의 '곱' 구하기
let m = 1; //--변수 할당은 0 아닌 '1'
for (var i = 1; i < 6; i++) {
  m *= i;
}
console.log(m);

//'빅오표기법'은 얼마만큼의 반복을 하고 있는지 알아보는 척도

//15번-19번줄 까지의 코드는 아래처럼 작성가능
let n = 100;
let s = 0;
for (var i = 1; i < n + 1; i++) {
  s += i;
}
console.log(s);
// O(n) --n이 커지면 커질수록 반복횟수가 늘어난다 -> n에 비례함

//15번-19번줄 코드에서의 연산은 100번 순회를 하는 것임
//   시그마 공식 : n(n+1)/2 => 전체 합과 같다
console.log((n * (n + 1)) / 2);
// O(1) --반복이 없고 바로 실행됨

//Point: 풀려는 문제에 대한 수학공식이 있는지 찾아보고 있으면 적용해서 푼다

// 재귀함수
// 내가 나를 호출하는 함수
// 반복문으로 표현가능한 것은 재귀함수로도 가능, 역 성립

//   function f(n) {
//     if (n <= 1) { // <-종료조건(base case)
//       return 1;
//     }
//     return n + f(n - 1); // <-재귀단계(recursive case)
//   }
//   console.log(`재귀함수 : ${f(100)}`);

function f(n) {
  if (n == 1) {
    // <-종료조건(base case)
    return 1;
  }
  return n * f(n - 1); // <-재귀단계(recursive case)
}
console.log(`재귀함수 : ${f(5)}`);

// 위의 재귀함수의 연산방식
// 순번   f(n)    n   return      최종        순번(스택에서 pop(반환)할 호출순서)
// 1  5   f(5)    5    5 * f(4)    5 * 24     5
// 2  4   f(4)    4    4 * f(3)    4 * 6      4
// 3  3   f(3)    3    3 * f(2)    3 * 2      3
// 4  2   f(2)    2    2 * f(1)    2 * 1      2
// 5  1    f(1)    1    1                     1

// => 실제연산순서(stack의 pop연산): f(1)->f(2)->f(3)->f(4)-> 'f(5)' --구하려는 값
