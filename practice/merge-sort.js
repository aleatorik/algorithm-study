// 병합정렬(O(nLogn)) --다른 어떤 정렬보다 빠름 (cf: 삽입정렬, 선택정렬, 버블정렬은 O(2의 n제곱))

let 입력값 = [5, 10, 66, 77, 54, 32, 11, 15];

//분할
/*
[5, 10, 66, 77] , [54, 32, 11, 15];
[5, 10], [66, 77] , [54, 32], [11, 15];
[5], [10], [66], [77] , [54], [32], [11], [15];

//정복 --두 개를 합칠 때 작은 값이 앞으로 오게 정렬
[5, 10], [66, 77], [32, 54], [11, 15] //어짜피 정렬되어있기 때문에 0번째만 비교 --5와 66을 비교
[ , ], [ , ], [ , ], [ , ]
[5, 10, 66, 77], [11, 15, 32, 54] //0번째 끼리 비교
[5, 10, 11, 15, 32, 54, 66, 77]
*/

//재귀함수로 구현
/*
function 병합정렬(입력배열) {
  let 입력배열의길이 = 입력배열.length;
  if (입력배열의길이 <= 1) {
    return 입력배열;
  }
  let 중간값 = parseInt(입력배열의길이 / 2); //왜 중간값(인덱스)을 알아야하냐면 분할을 하기 위해서는 어디에서 잘라서 배열을 만들지 계산해야하기 때문
  let 그룹하나 = 병합정렬(입력배열.slice(0, 중간값)); //초기값은 생략안되므로 꼭 넣어줘야함
  let 그룹둘 = 병합정렬(입력배열.slice(중간값)); //중간값부터 마지막까지 자름 ->두번 째 인자 마지막 부분은 입력안해도 자동으로 마지막까지 자름
  return `그룹하나 : ${그룹하나} 그룹둘 : ${그룹둘}\n` //분할 된 것을 리턴
}
//여기까지가 분할. 이제 합쳐야 함(정복) 
console.log(병합정렬(입력값));
*/

function 병합정렬(입력배열) {
  let 입력배열의길이 = 입력배열.length;
  let 결과값 = []; //정렬된 값을 넣어줌
  if (입력배열의길이 <= 1) {
    return 입력배열;
  }
  let 중간값 = parseInt(입력배열의길이 / 2);
  let 그룹하나 = 병합정렬(입력배열.slice(0, 중간값));
  let 그룹둘 = 병합정렬(입력배열.slice(중간값));

  while (그룹하나.length != 0 && 그룹둘.length != 0) {
    //그룹.length !=0 means 원소들이 남아있을 때 (그룹하나와 그룹둘 모두 요소가 남아있을 때)
    if (그룹하나[0] < 그룹둘[0]) {
      //원소가 다 떨어지면 뒤에 것을 그냥 이어붙이면 되기 때문에 이렇게 코드 작성
      결과값.push(그룹하나.shift()); //그룹하나[0]을 push할 경우 그룹하나에 값이 남아있기 때문에 무한반복에 빠짐
    } else {
      결과값.push(그룹둘.shift());
    }
  }

  while (그룹하나.length != 0) {
    //그룹.length !=0 means 원소들이 남아있을 때 (그룹하나에만 요소가 남아있을 때)
    결과값.push(그룹하나.shift()); //그룹하나에만 요소가 남아있으므로 그룹하나에서 shift로 값만 넣어주면 됨
  }

  while (그룹둘.length != 0) {
    //그룹.length !=0 means 원소들이 남아있을 때 (그룹둘에만 요소가 남아있을 때)
    결과값.push(그룹둘.shift()); //그룹둘에만 요소가 남아있으므로 그룹둘에서 shift로 값만 넣어주면 됨
  }
  return 결과값;
}
console.log(병합정렬(입력값));
